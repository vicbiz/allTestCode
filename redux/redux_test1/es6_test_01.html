<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>React & Redux</title>
    <style>
        table {
            border-collapse: collapse;
        }

        td {
            border: 1px solid #ccc;
            padding: 10px;
        }
    </style>
</head>

<body>

    <div>
        <p>Eegular Expression</p>
        <table>
            <colgroup>
                <col class="heading">
                <col>
            </colgroup>
            <colgroup>
                <col>
            </colgroup>
            <thead>
                <tr>
                    <th>메타 문자</th>
                    <th>의미</th>
                    <th>예</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>^</td>
                    <td>문자열의 시작. [...] 내에서 쓰이면 “<strong>일치하지 않는</strong>“의 의미가 된다.</td>
                    <td>^http는 문자열의 맨 처음에 http가 온 경우에 매치한다. (중간에 http가 나타난 경우는 매치하지 않음)</td>
                </tr>
                <tr>
                    <td>$</td>
                    <td>문자열의 끝</td>
                    <td>them$은 문자열이 them으로 끝난 경우에 them에매치한다.</td>
                </tr>
                <tr>
                    <td>\b</td>
                    <td>단어의 경계. 공백, 탭, 컴마, 대시 등이 올 수 있다.</td>
                    <td>\bplay\b는 play 의 양 끝에 단어 경계가 오는 경우에만 play에 매치한다. 따라서 “playground”의 play에는 매치하지 않는다.</td>
                </tr>
                <tr>
                    <td>\B</td>
                    <td>\b가 아닌 것. 정규식 메타문자에서는 대소문자가 바뀌면 반대의 의미를 지니는 것들이 있다.</td>
                    <td>\bplay\B는 play뒤에 단어 경계가 아닌 것이 왔을 때 play에 매치한다. 따라서 play에는 매치하지 않지만 playground, playball의 play에는 매치한다.</td>
                </tr>
                <tr>
                    <td>\s</td>
                    <td>공백문자</td>
                    <td>공백, 탭에 매치한다.</td>
                </tr>
                <tr>
                    <td>\S</td>
                    <td>공백문자가 아닌것</td>
                    <td>공백 문자가 아닌 모든 문자에 매치한다.</td>
                </tr>
                <tr>
                    <td>\d</td>
                    <td>숫자. [0-9]와 같다.</td>
                    <td></td>
                </tr>
                <tr>
                    <td>\D</td>
                    <td>숫자가 아닌 것. [^0-9]와 같다.</td>
                    <td></td>
                </tr>
                <tr>
                    <td>\w</td>
                    <td>word. 알파벳로마자에 매치한다.</td>
                    <td></td>
                </tr>
                <tr>
                    <td>\W</td>
                    <td>not word. 알파벳로마자가 아닌 것에 매치한다.</td>
                    <td></td>
                </tr>
                <tr>
                    <td>\n, \r</td>
                    <td>개행 문자 및 캐리지 리턴에 매치한다.</td>
                    <td></td>
                </tr>
                <tr>
                    <td>\</td>
                    <td>이스케이프 문자. 여러 메타 문자들을 이스케이프하여 그대로 사용할 수 있게 한다.</td>
                    <td>*, ?, +, [, { ,(, ), }, ], ^, $, |, \, . 등</td>
                </tr>
                <tr>
                    <td>.</td>
                    <td>임의의 문자 하나에 대응한다.</td>
                    <td></td>
                </tr>
            </tbody>
        </table>

        <br/><br/>









        <table class="forumline" width="100%" border="1" cellpadding="8" cellspacing="1">
            <tbody>
                <tr>
                    <td class="roww2" width="20%"><span style="color: red;">^</span>The</td>
                    <td class="roww2">The로 <span style="color: blue;">시작하는</span> 문자열</td>
                </tr>
                <tr>
                    <td class="roww2">of despair<span style="color: red;">$</span></td>
                    <td class="roww2">of despair로 <span style="color: blue;">끝나는</span> 문자열</td>
                </tr>
                <tr>
                    <td class="roww2"><span style="color: red;">^</span>abc<span style="color: red;">$</span></td>
                    <td class="roww2">abc로 시작하고 abc로 끝나는 문자열 (abc 라는 문자열도 해당됨)</td>
                </tr>
                <tr>
                    <td class="roww2">notice</td>
                    <td class="roww2">notice가 들어 있는 문자열</td>
                </tr>
            </tbody>
        </table>
        <br/><br/>

        <table class="forumline" width="100%" border="1" cellpadding="8" cellspacing="1">
            <tbody>
                <tr>
                    <td class="roww2" width="20%">ab<span style="color: red;">*</span></td>
                    <td class="roww2">a 다음에 b가 <span style="color: blue;">0개 이상</span> (a, ab, abbb 등등)
                    </td>
                </tr>
                <tr>
                    <td class="roww2">ab<span style="color: red;">+</span></td>
                    <td class="roww2">a 다음에 b가 <span style="color: blue;">1개 이상</span> (ab, abbb 등등)
                    </td>
                </tr>
                <tr>
                    <td class="roww2">ab<span style="color: red;">?</span></td>
                    <td class="roww2">a 다음에 b가 <span style="color: blue;">있거나 없거나</span> (ab 또는 a)
                    </td>
                </tr>
            </tbody>
        </table>
        <br/><br/>

        <table class="forumline" width="100%" border="1" cellpadding="8" cellspacing="1">
            <tbody>
                <tr>
                    <td class="roww2" width="20%">ab<span style="color: red;">{2}</span></td>
                    <td class="roww2">a 다음에 b가 <span style="color: blue;">2개 있는 문자열</span>
                        (abb)</td>
                </tr>
                <tr>
                    <td class="roww2">ab<span style="color: red;">{2,}</span></td>
                    <td class="roww2">a 다음에 b가 <span style="color: blue;">2개 이상</span> (abb, abbbb 등등)
                    </td>
                </tr>
                <tr>
                    <td class="roww2">ab<span style="color: red;">{3,5}</span></td>
                    <td class="roww2">a 다음에 b가 <span style="color: blue;">3개에서 5개 사이</span> (abbb, abbbb, 또는 abbbbb)</td>
                </tr>
            </tbody>
        </table>
        *, +, ?는 각각 {0,}, {1,}, {0,1}과 같습니다.
        <br/><br/>

        <table class="forumline" width="100%" border="1" cellpadding="8" cellspacing="1">
            <tbody>
                <tr>
                    <td class="roww1" colspan="2"><span style="color: red;">( )</span>는 문자열을 묶음 처리할 때 사용
                    </td>
                </tr>
                <tr>
                    <td class="roww2" width="20%">a<span style="color: red;">(bc)</span>*</td>
                    <td class="roww2">a 다음에 <span style="color: blue;">bc</span>가 0개 이상 (묶음 처리)
                    </td>
                </tr>
                <tr>
                    <td class="roww2">a<span style="color: red;">(bc)</span>{1,5}</td>
                    <td class="roww2">a 다음에 <span style="color: blue;">bc</span>가 1개에서 5개 사이
                    </td>
                </tr>
            </tbody>
        </table>
        <br/><br/>

        <table class="forumline" width="100%" border="1" cellpadding="8" cellspacing="1">
            <tbody>
                <tr>
                    <td class="roww1" width="20%">hi<span style="color: red;">|</span>hello</td>
                    <td class="roww1">hi<span style="color: blue;">나</span> hello가 들어 있는 문자열</td>
                </tr>
                <tr>
                    <td class="roww2">(b<span style="color: red;">|</span>cd)ef</td>
                    <td class="roww2">bef <span style="color: blue;">또는</span> cdef</td>
                </tr>
                <tr>
                    <td class="roww2">(a<span style="color: red;">|</span>b)*c</td>
                    <td class="roww2">a와 b가 섞여서 여러번 나타나고 그뒤에 c가 붙어있는 패턴</td>
                </tr>
            </tbody>
        </table>
        <br/><br/>

        <table class="forumline" width="100%" border="1" cellpadding="8" cellspacing="1">
            <tbody>
                <tr>
                    <td class="roww1" width="20%"><span style="color: red;">.</span> (점)</td>
                    <td class="roww1">임의의 한 문자</td>
                </tr>
                <tr>
                    <td class="roww2">^<span style="color: red;">.</span>{3}$</td>
                    <td class="roww2">3문자로만 되어 있는 문자열</td>
                </tr>
            </tbody>
        </table>
        <br/><br/>

        <table class="forumline" width="100%" border="1" cellpadding="8" cellspacing="1">
            <tbody>
                <tr>
                    <td class="roww1" width="20%"><span style="color: red;">[ ]</span></td>
                    <td class="roww1">괄호 안에 있는 내용 중 임의의 한 문자</td>
                </tr>
                <tr>
                    <td class="roww1"><span style="color: red;">[^ ]</span></td>
                    <td class="roww1">첫문자로 ^를 쓰면 괄호 내용의 부정. 즉 괄호 안에 포함되지 않는 한 문자</td>
                </tr>
                <tr>
                    <td class="roww2"><span style="color: red;">[</span>ab<span style="color: red;">]</span></td>
                    <td class="roww2">a <span style="color: blue;">또는</span> b (<span style="color: green;">a|b</span> 와
                        동일한 표현)</td>
                </tr>
                <tr>
                    <td class="roww2"><span style="color: red;">[</span>a-d<span style="color: red;">]</span></td>
                    <td class="roww2">소문자 a<span style="color: blue;">에서</span> d<span style="color: blue;">까지</span> (<span
                            style="color: green;">a|b|c|d</span>
                        또는
                        <span style="color: green;">[abcd]</span> 와 동일)</td>
                </tr>
                <tr>
                    <td class="roww2">^<span style="color: red;">[</span>a-zA-Z<span style="color: red;">]</span></td>
                    <td class="roww2">영문자로 시작하는 문자열</td>
                </tr>
                <tr>
                    <td class="roww2"><span style="color: red;">[</span>0-9<span style="color: red;">]</span>%</td>
                    <td class="roww2">% 문자 앞에 하나의 숫자가 붙어 있는 패턴</td>
                </tr>
                <tr>
                    <td class="roww2">%<span style="color: red;">[</span>^a-zA-Z<span style="color: red;">]</span>%</td>
                    <td class="roww2">두 % 문자 사이에 영문자가 없는 패턴</td>
                </tr>
            </tbody>
        </table>
        <br/><br/>

        <table class="forumline" width="100%" border="1" cellpadding="8" cellspacing="1">
            <tbody>
                <tr align="middle">
                    <td class="roww1" colspan="4">특수 문자 자체를 검색하기 및 사용하기</td>
                </tr>
                <tr align="middle">
                    <td class="roww2" width="20%">\^</td>
                    <td class="roww2" width="30%">^</td>
                    <td class="roww2" width="20%">\.</td>
                    <td class="roww2" width="30%">.</td>
                </tr>
                <tr align="middle">
                    <td class="roww2">\[</td>
                    <td class="roww2">[</td>
                    <td class="roww2">\$</td>
                    <td class="roww2">$</td>
                </tr>
                <tr align="middle">
                    <td class="roww2">\(</td>
                    <td class="roww2">(</td>
                    <td class="roww2">\)</td>
                    <td class="roww2">)</td>
                </tr>
                <tr align="middle">
                    <td class="roww2">\|</td>
                    <td class="roww2">|</td>
                    <td class="roww2">\*</td>
                    <td class="roww2">*</td>
                </tr>
                <tr align="middle">
                    <td class="roww2">\+</td>
                    <td class="roww2">+</td>
                    <td class="roww2">\?</td>
                    <td class="roww2">?</td>
                </tr>
                <tr align="middle">
                    <td class="roww2">\{</td>
                    <td class="roww2">{</td>
                    <td class="roww2">\\</td>
                    <td class="roww2">\</td>
                </tr>
                <tr align="middle">
                    <td class="roww1">\n</td>
                    <td class="roww2">줄넘김 문자</td>
                    <td class="roww1">\r</td>
                    <td class="roww2">리턴 문자</td>
                </tr>
                <tr align="middle">
                    <td class="roww1">\w</td>
                    <td class="roww2">알파벳과 _ (언더바)</td>
                    <td class="roww1">\W</td>
                    <td class="roww2">알파벳과 _ 가 아닌 것</td>
                </tr>
                <tr align="middle">
                    <td class="roww1">\s</td>
                    <td class="roww2">빈 공간(space)</td>
                    <td class="roww1">\S</td>
                    <td class="roww2">빈 공간이 아닌 것</td>
                </tr>
                <tr align="middle">
                    <td class="roww1">\d</td>
                    <td class="roww2">숫자</td>
                    <td class="roww1">\D</td>
                    <td class="roww2">숫자가 아닌 것</td>
                </tr>
                <tr align="middle">
                    <td class="roww1">\b</td>
                    <td class="roww2">단어와 단어 사이의 경계</td>
                    <td class="roww1">\B</td>
                    <td class="roww2">단어 사이의 경계가 아닌 것</td>
                </tr>
                <tr align="middle">
                    <td class="roww1">\t</td>
                    <td class="roww2">Tab 문자</td>
                    <td class="roww1">\xnn</td>
                    <td class="roww2">16진수 nn에 해당하는 문자</td>
                </tr>
            </tbody>
        </table>
        [ ] 안에서는 특수 문자가 모두 효력을 잃게 됩니다.
        <br/><br/>

        <table class="forumline" style="line-height: 160%; text-align: justify;" width="100%" border="0" cellpadding="8" cellspacing="1">
            <tbody>
                <tr>
                    <td class="roww1"><span style="color: red;">검색</span> + <span style="color: red;">치환</span>을 위한 <span
                            style="color: red;">하부식</span>(<span style="color: red;">부분식</span>) </td>
                </tr>
                <tr>
                    <td class="roww2"><span style="color: red;">( )</span>로 <span style="color: blue;">둘러싼 부분은 각각 하나의 덩어리로
                            취급</span>해서,<br>검색시
                        <span style="color: red;">( )</span> <span style="color: blue;">안에 해당되는 내용들을 변경할 내용에서 그대로 가져다 이용</span>할
                        수 있습니다.<br>검색된 각각의 <span style="color: red;">( )</span>안에 해당되는 내용은 변경할 내용에서 <span style="color: red;">$1,
                            $2, .. 등으로 지정</span>해서 쓸 수 있습니다.
                    </td>
                </tr>
                <tr>
                    <td class="roww2">예제) mp3파일 이름 바꾸기<br>검색 : <span style="color: red;">(</span>.*<span style="color: red;">)</span>
                        - <span style="color: red;">(</span>.*<span style="color: red;">)</span>\.mp3 .*은 길이에 상관없이 임의의 문자열,
                        \.은 점<br>치환 : <span style="color: red;">$2</span> - <span style="color: red;">$1</span>.mp3 앞에서 검색한
                        ( )안에 해당되는 내용끼리 순서 바꾸기
                        <br>ex) "제목 - 연주자.mp3" Þ "연주자 - 제목.mp3" </td>
                </tr>
                <tr>
                    <td class="roww1">앞에서 정의한 하부식을 다시 활용하기 (제가 잘못 이해한 것일 수도 있는데) </td>
                </tr>
                <tr>
                    <td class="roww2"><span style="color: red;">\n</span>은 ( ) 하부식 중에서 <span style="color: blue;">n번째 하부식</span>을
                        가리킵니다. </td>
                </tr>
                <tr>
                    <td class="roww2">예제) (.+)<span style="color: red;">\1</span>+<br><span style="color: red;">\1</span>로
                        되어 있으니까 첫번째 부분식 (.+)를 가리킵니다. 위 내용을 해석하자면, 일단 (.+)가 있으니까 이에 해당되는 내용을 찾고, <span style="color: red;">\1</span>+이
                        있으니까 첫번째 부분식 (.+)와 똑같은 내용이 그 뒤에 1번 이상 있는 문자열을 찾습니다. </td>
                </tr>
                <tr>
                    <td class="roww2">예제) <span style="color: blue;">ab</span><span style="color: red;">ab</span>같은 문자열이
                        위에 해당되는데, 일단 (.+) 즉 임의의 문자열 ab를 찾고 그 뒤에 \1+로 첫번째 부분식을 다시 1번 이상 있는 것을 찾으니까 뒤의 ab가 이에 해당합니다. </td>
                </tr>
            </tbody>
        </table>
        <br/><br/>

        <table class="forumline" width="100%" border="1" cellpadding="8" cellspacing="1">
            <tbody>
                <tr>
                    <td class="roww1" colspan="2">변경자 ? 검색 방식 변경</td>
                </tr>
                <tr>
                    <td class="roww2" width="20%">(?i)</td>
                    <td class="roww2">대소문자 무시 (기본값)</td>
                </tr>
                <tr>
                    <td class="roww2">(?-i)</td>
                    <td class="roww2">대소문자 구분</td>
                </tr>
                <tr>
                    <td class="roww2">(?g)</td>
                    <td class="roww2">"greedy" 모드로 전환 (기본값)</td>
                </tr>
                <tr>
                    <td class="roww2">(?-g)</td>
                    <td class="roww2">"greedy" 모드 해제, 따라서 "+"는 "+?"과 동일한 것으로 인식
                    </td>
                </tr>
            </tbody>
        </table>
        <br/><br/>












        <br/><br/>

        <table class="standard-table">
            <caption>Special characters in regular expressions.</caption>
            <thead>
                <tr>
                    <th scope="col">Character</th>
                    <th scope="col">Meaning</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><a id="special-backslash" href="#special-backslash" name="special-backslash">\</a></td>
                    <td>
                        <p>Matches according to the following rules:<br>
                            <br> A backslash that precedes a non-special character indicates that the next character is special
                            and is not to be interpreted literally. For example, a 'b' without a preceding '\' generally
                            matches lowercase 'b's wherever they occur. But a '\b' by itself doesn't match any character;
                            it denotes a&nbsp;<a href="#special-word-boundary" title="#special-word-boundary">word boundary</a>.<br>
                            <br> A backslash that precedes a special character indicates that the next character is not special
                            and should be interpreted literally. For example, the pattern /a*/ relies on the special character
                            '*' to match 0 or more a's. By contrast, the pattern /a\*/ denotes&nbsp;the '*'&nbsp; as not
                            special, enabling&nbsp;matches with strings like 'a*'.<br>
                            <br> Do not forget to escape \ itself while using the RegExp("pattern") notation because \ is
                            also an escape character in strings.</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-caret" href="#special-caret" name="special-caret">^</a></td>
                    <td>Matches beginning of input. If the multiline flag is set to true, also matches immediately after
                        a line break character.
                        <br>
                        <br> For example, /^A/ does not match the 'A' in "an A", but does match the 'A' in "An E".<br>
                        <br> The '^' has a different meaning when it appears as the first character in a character set pattern.
                        See <a href="#special-negated-character-set" title="#special-negated-character-set">complemented
                            character sets</a> for details and an example.</td>
                </tr>
                <tr>
                    <td><a id="special-dollar" href="#special-dollar" name="special-dollar">$</a></td>
                    <td>
                        <p>Matches end of input. If the multiline flag is set to true, also matches immediately before a
                            line break character.
                        </p>

                        <p>For example, /t$/ does not match the 't' in "eater", but does match it in "eat".</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-asterisk" href="#special-asterisk" name="special-asterisk">*</a></td>
                    <td>
                        <p>Matches the preceding expression 0 or more times. Equivalent to {0,}.</p>

                        <p>For example, /bo*/ matches 'boooo' in "A ghost booooed" and 'b' in&nbsp;"A bird warbled" but nothing
                            in&nbsp;"A goat grunted".</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-plus" href="#special-plus" name="special-plus">+</a></td>
                    <td>
                        <p>Matches the preceding expression 1 or more times. Equivalent to {1,}.</p>

                        <p>For example, /a+/ matches the 'a' in "candy" and all the a's in "caaaaaaandy", but nothing in
                            "cndy".</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-questionmark" href="#special-questionmark" name="special-questionmark">?</a></td>
                    <td>Matches the preceding expression 0 or 1 time. Equivalent to {0,1}.<br>
                        <br> For example, /e?le?/ matches the 'el' in "angel" and the 'le' in "angle" and also the 'l' in
                        "oslo".<br>
                        <br> If used immediately after any of the quantifiers *, +, ?, or {}, makes the quantifier non-greedy
                        (matching the fewest possible characters), as opposed to the default, which is greedy (matching as
                        many characters as possible). For example, applying /\d+/ to "123abc" matches "123". But applying
                        /\d+?/ to that same string matches only the "1".<br>
                        <br> Also used in lookahead assertions, as described in the x(?=y) and x(?!y) entries of this table.<br>                        &nbsp;
                    </td>
                </tr>
                <tr>
                    <td><a id="special-dot" href="#special-dot" name="special-dot">.</a></td>
                    <td>
                        <p>(The decimal point) matches any single character except the newline character.</p>

                        <p>For example, /.n/ matches 'an' and 'on' in "nay, an apple is on the tree", but not 'nay'.</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-capturing-parentheses" href="#special-capturing-parentheses" name="special-capturing-parentheses">(x)</a></td>
                    <td>
                        <p>Matches 'x' and remembers the match, as the following example shows. The parentheses are called
                            <em>capturing parentheses
                            </em>.<br>
                            <br> The '(foo)' and '(bar)' in the pattern /(foo) (bar) \1 \2/ match and remember the first
                            two words in the string "foo bar foo bar". The \1 and \2&nbsp; denote the first and second parenthesized
                            substring matches -&nbsp;foo&nbsp;and bar, matching the string's last two words. Note that \1,
                            \2, ...,&nbsp;\n are used in the matching part of the regex, for more information, see <a href="#special-backreference">\n</a>&nbsp;below.
                            In the replacement part of a regex the syntax $1, $2, ...,&nbsp;$n must be used, e.g.: 'bar foo'.replace(/(...)
                            (...)/, '$2 $1'). &nbsp;$&amp; means the whole matched string.</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-non-capturing-parentheses" href="#special-non-capturing-parentheses" name="special-non-capturing-parentheses">(?:x)</a></td>
                    <td>Matches 'x' but does not remember the match. The parentheses are called <em>non-capturing parentheses</em>,
                        and let you define subexpressions for regular expression operators to work with. Consider the sample
                        expression /(?:foo){1,2}/. If the expression was /foo{1,2}/, the {1,2} characters would apply only
                        to the last 'o' in 'foo'. With the non-capturing parentheses, the {1,2} applies to the entire word
                        'foo'. For more information, see <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_parentheses">Using
                            parentheses
                        </a> below.</td>
                </tr>
                <tr>
                    <td><a id="special-lookahead" href="#special-lookahead" name="special-lookahead">x(?=y)</a></td>
                    <td>
                        <p>Matches 'x' only if 'x' is followed by 'y'. This is called a lookahead.</p>

                        <p>For example, /Jack(?=Sprat)/ matches 'Jack' only if it is followed by 'Sprat'. /Jack(?=Sprat|Frost)/
                            matches 'Jack' only if it is followed by 'Sprat' or 'Frost'. However, neither 'Sprat' nor 'Frost'
                            is part of the match results.</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-negated-look-ahead" href="#special-negated-look-ahead" name="special-negated-look-ahead">x(?!y)</a></td>
                    <td>
                        <p>Matches 'x' only if 'x' is not followed by 'y'. This is called a negated lookahead.</p>

                        <p>For example, /\d+(?!\.)/ matches a number only if it is not followed by a decimal point. The regular
                            expression /\d+(?!\.)/.exec("3.141") matches '141' but not '3.141'.</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-or" href="#special-or" name="special-or">x|y</a></td>
                    <td>
                        <p>Matches 'x', or 'y' (if there is no match for 'x').</p>

                        <p>For example, /green|red/ matches 'green' in "green apple" and 'red' in "red apple." The order
                            of 'x' and 'y' matters. For example a*|b&nbsp;matches the empty string in "b", but b|a* matches
                            "b" in the same string.</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-quantifier" href="#special-quantifier" name="special-quantifier">{n}</a></td>
                    <td>Matches exactly n occurrences of the preceding expression. N must be a positive integer.<br>
                        <br> For example, /a{2}/ doesn't match the 'a' in "candy," but it does match all of the a's in "caandy,"
                        and the first two a's in "caaandy."</td>
                </tr>
                <tr>
                    <td><a id="special-quantifier" href="#special-quantifier" name="special-quantifier">{n,}</a></td>
                    <td>
                        <p>Matches at least n occurrences of the preceding expression. N must be a positive integer.</p>

                        <p>For example, /a{2,}/ will match "aa", "aaaa" and "aaaaa" but not "a"</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-quantifier-range" href="#special-quantifier-range" name="special-quantifier-range">{n,m}</a></td>
                    <td>
                        <p>Where n and m are positive integers and n &lt;= m. Matches at least n and at most m occurrences
                            of the preceding expression. When m is omitted, it's treated as ∞.</p>

                        <p>For example, /a{1,3}/ matches nothing in "cndy", the 'a' in "candy," the first two a's in "caandy,"
                            and the first three a's in "caaaaaaandy". Notice that when matching "caaaaaaandy", the match
                            is "aaa", even though the original string had more a's in it.</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-character-set" href="#special-character-set" name="special-character-set">[xyz]</a></td>
                    <td>Character set. This pattern type matches any one of the characters in the brackets, including <a
                            href="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Values,_variables,_and_literals#Unicode_escape_sequences"
                            title="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Values,_variables,_and_literals#Unicode_escape_sequences">escape
                            sequences
                        </a>. Special characters like the dot(.) and asterisk (*) are not special inside a character set,
                        so they don't need to be escaped. You can specify a range of characters by using a hyphen, as the
                        following examples illustrate.<br>
                        <br> The pattern [a-d], which performs the same match as [abcd], matches the 'b' in "brisket" and
                        the 'c' in "city". The patterns /[a-z.]+/ and /[\w.]+/ match the entire string "test.i.ng".</td>
                </tr>
                <tr>
                    <td><a id="special-negated-character-set" href="#special-negated-character-set" name="special-negated-character-set">[^xyz]</a></td>
                    <td>
                        <p>A negated or complemented character set. That is, it matches anything that is not enclosed in
                            the brackets. You can specify a range of characters by using a hyphen. Everything that works
                            in the normal character set also works here.</p>

                        <p>For example, [^abc] is the same as [^a-c]. They initially match 'r' in "brisket" and 'h'&nbsp;in
                            "chop."</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-backspace" href="#special-backspace" name="special-backspace">[\b]</a></td>
                    <td>Matches a backspace (U+0008). You need to use square brackets if you want to match a literal backspace
                        character. (Not to be confused with \b.)</td>
                </tr>
                <tr>
                    <td><a id="special-word-boundary" href="#special-word-boundary" name="special-word-boundary">\b</a></td>
                    <td>
                        <p>Matches a <em>word boundary</em>. A word boundary matches the position between a word character
                            followed by a non-word character, or between a non-word character followed by a word character,
                            or the beginning of the string, or the end of the string. A word boundary is not a "character"
                            to be matched; like an anchor, a word boundary is not included in the match. In other words,
                            the length of a matched word boundary is zero. (Not to be confused with [\b].)</p>

                        <p>Examples using the input string "moon":<br> /\bm/ matches, because the `\b` is at the beginning
                            of the string;<br> the&nbsp;'\b' in&nbsp;/oo\b/ does not match, because the '\b' is both preceded
                            and followed by word characters;<br> the '\b' in&nbsp;/oon\b/ matches, because it appears at
                            the end of the string;<br> the '\b\ in&nbsp;/\w\b\w/ will never match anything, because it is
                            both preceded and followed by a word character..</p>

                        <div class="note">
                            <p><strong>Note:</strong>&nbsp;JavaScript's regular expression engine defines a <a rel="noopener"
                                    href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.6" class="external external-icon">specific
                                    set of characters</a> to be "word" characters. Any character not in that set is considered
                                a non-word character. This set of characters is fairly limited: it consists solely of the&nbsp;Roman
                                alphabet in both upper- and lower-case, decimal digits, and the underscore character. Accented
                                characters, such as "é" or "ü" are, unfortunately, treated as non-word characters for the
                                purposes of&nbsp;word boundaries, as are ideographic characters in general.</p>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-non-word-boundary" href="#special-non-word-boundary" name="special-non-word-boundary">\B</a></td>
                    <td>
                        <p>Matches a non-<em>word boundary</em>. This matches&nbsp;the following cases:</p>

                        <ul>
                            <li>Before the first character of the string.</li>
                            <li>After the last character of the string,.</li>
                            <li>Between two word characters</li>
                            <li>Between two non-word characters</li>
                            <li>The empty string</li>
                        </ul>

                        <p>For example, /\B../ matches 'oo' in "noonday", and /y\B./ matches 'ye' in "possibly yesterday."
                        </p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-control" href="#special-control" name="special-control">\c<em>X</em></a></td>
                    <td>
                        <p>Where <em>X</em> is a character ranging from A to Z. Matches a control character in a string.</p>

                        <p>For example, /\cM/ matches control-M (U+000D) in a string.</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-digit" href="#special-digit" name="special-digit">\d</a></td>
                    <td>
                        <p>Matches a&nbsp;digit character. Equivalent to [0-9].</p>

                        <p>For example, /\d/ or /[0-9]/ matches '2' in "B2 is the suite number."</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-non-digit" href="#special-non-digit" name="special-non-digit">\D</a></td>
                    <td>
                        <p>Matches a&nbsp;non-digit character. Equivalent to [^0-9].</p>

                        <p>For example, /\D/ or /[^0-9]/ matches 'B' in "B2 is the suite number."</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-form-feed" href="#special-form-feed" name="special-form-feed">\f</a></td>
                    <td>Matches a form feed (U+000C).</td>
                </tr>
                <tr>
                    <td><a id="special-line-feed" href="#special-line-feed" name="special-line-feed">\n</a></td>
                    <td>Matches a line feed (U+000A).</td>
                </tr>
                <tr>
                    <td><a id="special-carriage-return" href="#special-carriage-return" name="special-carriage-return">\r</a></td>
                    <td>Matches a carriage return (U+000D).</td>
                </tr>
                <tr>
                    <td><a id="special-white-space" href="#special-white-space" name="special-white-space">\s</a></td>
                    <td>
                        <p>Matches a white space character, including space, tab, form feed, line feed. Equivalent to [ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff].</p>

                        <p>For example, /\s\w*/ matches ' bar' in "foo bar."</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-non-white-space" href="#special-non-white-space" name="special-non-white-space">\S</a></td>
                    <td>
                        <p>Matches a character other than white space. Equivalent to [^ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff].</p>

                        <p>For example, /\S*/ matches 'foo' in "foo bar."</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-tab" href="#special-tab" name="special-tab">\t</a></td>
                    <td>Matches a tab (U+0009).</td>
                </tr>
                <tr>
                    <td><a id="special-vertical-tab" href="#special-vertical-tab" name="special-vertical-tab">\v</a></td>
                    <td>Matches a vertical tab (U+000B).</td>
                </tr>
                <tr>
                    <td><a id="special-word" href="#special-word" name="special-word">\w</a></td>
                    <td>
                        <p>Matches any alphanumeric character including the underscore. Equivalent to [A-Za-z0-9_].</p>

                        <p>For example, /\w/ matches 'a' in "apple," '5' in "$5.28," and '3' in "3D."</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-non-word" href="#special-non-word" name="special-non-word">\W</a></td>
                    <td>
                        <p>Matches any non-word character. Equivalent to [^A-Za-z0-9_].</p>

                        <p>For example, /\W/ or /[^A-Za-z0-9_]/ matches '%' in "50%."</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-backreference" href="#special-backreference" name="special-backreference">\<em>n</em></a></td>
                    <td>
                        <p>Where <em>n</em> is a positive integer, a back reference to the last substring matching the <em>n</em>
                            parenthetical in the regular expression (counting left parentheses).</p>

                        <p>For example, /apple(,)\sorange\1/ matches 'apple, orange,' in "apple, orange, cherry, peach."</p>
                    </td>
                </tr>
                <tr>
                    <td><a id="special-null" href="#special-null" name="special-null">\0</a></td>
                    <td>Matches a NULL (U+0000) character. Do not follow this with another digit, because \0&lt;digits&gt;
                        is an octal <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Values,_variables,_and_literals#Unicode_escape_sequences"
                            title="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Values,_variables,_and_literals#Unicode_escape_sequences">escape
                            sequence
                        </a>. Instead use \x00.</td>
                </tr>
                <tr>
                    <td><a id="special-hex-escape" href="#special-hex-escape" name="special-hex-escape">\xhh</a></td>
                    <td>Matches the character with the code hh (two hexadecimal digits)</td>
                </tr>
                <tr>
                    <td><a id="special-unicode-escape" href="#special-unicode-escape" name="special-unicode-escape">\uhhhh</a></td>
                    <td>Matches the character with the code hhhh (four hexadecimal digits).</td>
                </tr>
                <tr>
                    <td><a id="special-unicode-escape-es6" href="#special-unicode-escape-es6" name="special-unicode-escape-es6">\u{hhhh}</a></td>
                    <td>(only when u flag is set) Matches the character with the Unicode value hhhh (hexadecimal digits).</td>
                </tr>
            </tbody>
        </table>


    </div>

    <script src="https://fb.me/react-15.0.0.js"></script>
    <script src="https://fb.me/react-dom-15.0.0.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.34/browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/redux/3.6.0/redux.js"></script>

    <script type="text/babel">

        let ary = ["2","21","45","33","17"];
        console.log(ary.find(k => k == "45"));  // return 45
        console.log(ary.find(k => k == "145")); // return undefined not false....

console.log("\n[ find ]-----------------------------------------------------------------------\n");
        // Array.find(element, index, array)

        let inventory = [
            {name: "apple", quantity:2},
            {name: "cherries", quantity:23},
            {name: "babana", quantity:12},
            {name: "cherries", quantity:33},
        ];
        function isCherries(fruit){
            return fruit.name === 'cherries';
        }
        console.log(inventory.find(isCherries));

        // ES6
        let findCherry = inventory.find(fruit => fruit.name === 'cherries');
        console.log(findCherry.name, findCherry.quantity);



        console.log("find all using filter() ************************************");
        console.log(inventory.filter(isCherries));





console.log("\n[ find prime ]-----------------------------------------------------------------------\n");
        // Array.find(element, index, array)
/*
        function isPrime(element, index, array){
            console.log("element",element,"index",index,"array",array);
            var start = 2;
            console.log("Math.sqrt(element)",Math.sqrt(element));
            while(start <= Math.sqrt(element)){
                if(element % start++ < 1){
                    return false;
                }
            }
            console.log("2 start <= Math.sqrt(element)",start <= Math.sqrt(element));
            return element > 1;
        }
        console.log("first prime number ",[6,8,9,10,11,12,13].find(isPrime))
*/
console.log("\n[ find all prime ]-----------------------------------------------------------------------\n");

        function isPrime1(element, index, array){
            var start = 2;
            console.log("element",element,"start",start,"Math.sqrt(element)",Math.sqrt(element));
            while(start <= Math.sqrt(element)){
                console.log("element",element,"start",start);
                if(element % start++ < 1){
                    return false;
                }
            }
            console.log("element > 1");
            return element > 1;
        }

        function findAllPrime(element, index, array){
            // console.log(element, index, array);
            return isPrime1(element, index, array) ? {"number": element, "isPrime1":isPrime1(element, index, array)} : '';
        }
        console.log([1,2,3,4,5,6,7,8,9,10,11,12,13].map(findAllPrime))

console.log("\n[ findIndex() ]-----------------------------------------------------------------------\n");
        // Array.findIndex(element, index, array)

        const fruits = ["apple", "banana", "cantaloupe", "blueberries", "grapefruit"];

        const index = fruits.findIndex((fruit, index, array) => fruit === "blueberries");

        console.log(fruits,"index",index,fruits[index]); // 3, blueberries

console.log("\n[ Array.includes() ]-----------------------------------------------------------------------\n");
        // Array.includes(searchElemet [, fromIndex])

        var array1 = [1, 2, 3];
        console.log(array1,"array1.includes(2)",array1.includes(2));
        // expected output: true

        var pets = ['cat', 'dog', 'bat'];
        console.log(pets,"pets.includes('cat')",pets.includes('cat'));
        // expected output: true

        console.log(pets,"pets.includes('at')",pets.includes('at'));
        // expected output: false

        // Array.includes(searchElemet [, fromIndex])
        console.log([1, 2, 3].includes(2));     // true
        console.log([1, 2, 3].includes(4));     // false
        console.log([1, 2, 3].includes(3, 3));  // false
        console.log([1, 2, 3].includes(3, 2));  // true
        console.log([1, 2, 3].includes(3, -1)); // true
        console.log([1, 2, NaN].includes(NaN)); // true

console.log("\n[ Array.filter() ]-----------------------------------------------------------------------\n");
        // The filter() method creates a new array with all elements that pass the test implemented by the provided function.
        // IE doesn't support........
        // arr.filter(callback(element[, index[, array]])[, thisArg])

        function isBigEnough(value) {
            return value >= 10;
        }
        var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
        // filtered is [12, 130, 44]

        // find all prime using filter..... -----------------------------------------------------------
        function findAllPrime1(element, index, array){
            var start = 2;
            while(start <= Math.sqrt(element)){
                if(element % start++ < 1){
                    return false;
                }
            }
            return element > 1;
        }
        console.log([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20].filter(findAllPrime1)); // [ 2, 3, 5, 7, 11, 13 ]
        


        // Filtering invalid entries from JSON --------------------------------------------------------------------------------------------

        var arr = [
            { id: 15 },
            { id: -1 },
            { id: 0 },
            { id: 3 },
            { id: 12.2 },
            { },
            { id: null },
            { id: NaN },
            { id: 'undefined' }
        ];

        var invalidEntries = 0;

        function isNumber(obj) {
            return obj !== undefined && typeof(obj) === 'number' && !isNaN(obj);
        }

        function filterByID(item) {
            if (isNumber(item.id) && item.id !== 0) {
                return true;
            } 
            invalidEntries++;
            return false; 
        }

        var arrByID = arr.filter(filterByID);

        console.log('Filtered Array\n', arrByID); 
        // Filtered Array
        // [{ id: 15 }, { id: -1 }, { id: 3 }, { id: 12.2 }]

        console.log('Number of Invalid Entries = ', invalidEntries); 
        // Number of Invalid Entries = 5



        // Searching in array --------------------------------------------------------------------------------------------
        var fruits1 = ['apple', 'banana', 'grapes', 'mango', 'orange'];

        function filterItems1(query) {
            return fruits1.filter(function(el) {
                return el.toLowerCase().indexOf(query.toLowerCase()) > -1;
            })
        }

        console.log(filterItems1('ap')); // ['apple', 'grapes']
        console.log(filterItems1('an')); // ['banana', 'mango', 'orange']



        // ES2015 Implementation --------------------------------------------------------------------------------------------
        const fruits2 = ['apple', 'banana', 'grapes', 'mango', 'orange'];

        const filterItems2 = (query) => {
            return fruits2.filter(el =>
                el.toLowerCase().indexOf(query.toLowerCase()) > -1
            );
        }

        console.log(filterItems2('ap')); // ['apple', 'grapes']
        console.log(filterItems2('an')); // ['banana', 'mango', 'orange']

console.log("\n[ Array.every() ]-----------------------------------------------------------------------\n");
        // arr.every(callback(element[, index[, array]])[, thisArg])

        var array1 = [1, 30, 39, 29, 10, 13];

        console.log(array1.every(currentValue => currentValue < 30)); // false
        console.log(array1.every(currentValue => currentValue < 40)); // true

console.log("\n[ Array.some() ]-----------------------------------------------------------------------\n");
        // arr.some(callback[, thisArg])


        // Testing value of array elements
        [2, 5, 8, 1, 4].some(x => x > 10);  // false
        [12, 5, 8, 1, 4].some(x => x > 10); // true


        // Checking whether a value exists in an array
        var fruits3 = ['apple', 'banana', 'mango', 'guava'];
        function checkAvailability(arr, val) {
            return arr.some(function(arrVal) {
                return val === arrVal;
            });
        }
        console.log( checkAvailability(fruits3, 'kela') );   // false
        console.log( checkAvailability(fruits3, 'banana') ); // true


        // Converting any value to Boolean
        var TRUTHY_VALUES = [true, 'true', 1];

        function getBoolean(value) {
            'use strict';
            if (typeof value === 'string') { 
                value = value.toLowerCase().trim();
            }
            return TRUTHY_VALUES.some(function(t) {
                return t === value;
            });
        }
        getBoolean(false);   // false
        getBoolean('false'); // false
        getBoolean(1);       // true
        getBoolean('true');  // true


console.log("\n[ Array.of() ]-----------------------------------------------------------------------\n");
    // The Array.of() method creates a new Array instance with a variable number of arguments, regardless of number or type of the arguments.
    // The difference between Array.of() and the Array constructor is in the handling of integer arguments: Array.of(7) creates an array with a single element, 7, whereas Array(7) creates an empty array with a length property of 7 (Note: this implies an array of 7 empty slots, not slots with actual undefined values).
    // arr.copyWithin(target)

    Array.of(7);       // [7] 
    Array.of(1, 2, 3); // [1, 2, 3]

    Array(7);          // [ , , , , , , ]
    Array(1, 2, 3);    // [1, 2, 3]


console.log("\n[ Array.copyWithin() ]-----------------------------------------------------------------------\n");
    // The copyWithin() method shallow copies part of an array to another location in the same array and returns it, without modifying its size.
    // arr.copyWithin(target, start)
    // arr.copyWithin(target, start, end) // end not included

    var array1 = [1, 2, 3, 4, 5];
    // place at position 0 the element between position 3 and 4
    console.log(array1.copyWithin(0, 3, 4));
    // expected output: Array [4, 2, 3, 4, 5]

    // place at position 1 the elements after position 3
    console.log(array1.copyWithin(1, 3));
    // expected output: Array [4, 4, 5, 4, 5]


console.log("\n[ Array.forEach() ]-----------------------------------------------------------------------\n");
    // arr.forEach(function callback(currentValue[, index[, array]]) {
    //     //your iterator
    // }[, thisArg]);

    var array1 = ['a', 'b', 'c'];
    array1.forEach(function(element) {
        console.log(element);
    });


console.log("\n[ Array.join() ]-----------------------------------------------------------------------\n");
    // The join() method joins all elements of an array (or an array-like object) into a string and returns this string.

    var elements = ['Fire', 'Wind', 'Rain'];

    console.log(elements.join());
    // expected output: Fire,Wind,Rain

    console.log(elements.join(''));
    // expected output: FireWindRain

    console.log(elements.join('-'));
    // expected output: Fire-Wind-Rain


console.log("\n[ Array.keys() ]-----------------------------------------------------------------------\n");
    // The keys() method returns a new Array Iterator object that contains the keys for each index in the array.

    // ex1
    var array1 = ['a', 'b', 'c'];
    var iterator = array1.keys(); 
    for (let key of iterator) {
        console.log(key); // expected output: 0 1 2
    }

    // ex2
    var arr = ['a', , , , 'c'];
    var sparseKeys = Object.keys(arr);
    var denseKeys = [...arr.keys()];
    console.log(sparseKeys); // ['0', '4']
    console.log(denseKeys);  // [ 0, 1, 2, 3, 4 ]


console.log("\n[ Spread syntax ...Args ]-----------------------------------------------------------------------\n");
    // Spread syntax allows an iterable such as an array expression or string to be expanded in places where 
    // zero or more arguments (for function calls) or elements (for array literals) are expected, or an object 
    // expression to be expanded in places where zero or more key-value pairs (for object literals) are expected.

    function sum(x, y, z) {
        return x + y + z;
    }

    const numbers = [1, 2, 3, 4, 5];

    console.log(sum(...numbers));               // expected output: 6
    console.log(sum.apply(null, numbers));      // expected output: 6


console.log("\n[ .apply() ]-----------------------------------------------------------------------\n");
    // The apply() method calls a function with a given this value, and arguments provided as an array (or an array-like object).
    // function.apply(thisArg, [argsArray])

    // ex1 -------------------------------------------------------------------------------
    var numbers2 = [5, 6, 2, 3, 7];
    var max = Math.max.apply(null, numbers2);
    console.log(max);       // expected output: 7
    var min = Math.min.apply(null, numbers2);
    console.log(min);       // expected output: 2

    // ex2 -------------------------------------------------------------------------------
    var array = ['a', 'b'];
    var elements = ["0", 1, 2];
    var aa = function(arg){
        console.log("arg",arg);
    }
    console.log("aaa",aa.apply(array, elements));
    array.push.apply(array, elements);
    console.info(array); // ["a", "b", "0", 1, 2]

    // same....
    var array = ['a', 'b'];
    var elements = ["0", 1, 2];
    console.log(array.concat(elements)); // ["a", "b", "0", 1, 2]

    // ex3 : Using apply and built-in functions -------------------------------------------------------------------------------
    // min/max number in an array
    var numbers3 = [5, 6, 2, 3, 7];

    // using Math.min/Math.max apply
    var max = Math.max.apply(null, numbers3); 
    // This about equal to Math.max(numbers[0], ...)
    // or Math.max(5, 6, ...)

    var min = Math.min.apply(null, numbers3);

    // vs. simple loop based algorithm
    max = -Infinity, min = +Infinity;
    console.log(typeof(Infinity)); // number.... 

    for (var i = 0; i < numbers3.length; i++) {
        if (numbers3[i] > max) {
            max = numbers3[i];
        }
        if (numbers3[i] < min) {
            min = numbers3[i];
        }
    }
    console.log(numbers3,"max",max,"min",min);


    // Math.max() -----------------------------------------------------------------------------
    console.log(Math.max(1, 3, 2));     // expected output: 3
    console.log(Math.max(-1, -3, -2));  // expected output: -1

    var array1 = [1, 3, 2];
    console.log(Math.max(...array1));   // expected output: 3    


console.log("\n[ .bind() ]-----------------------------------------------------------------------\n");
    // The bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.

/*
    // ex1 -----------------------------------------------------------------------------
    this.x = 11;
    var module = {
        x: 42,
        getX: function() {
            return this.x;
        }
    }

    var unboundGetX = module.getX;
    console.log(unboundGetX()); // The function gets invoked at the global scope
    // expected output: undefined

    var boundGetX = unboundGetX.bind(module);
    console.log(boundGetX());
    // expected output: 42


    // ex2 -----------------------------------------------------------------------------
    this.x = 9;    // this refers to global "window" object here in the browser
    var module = {
        x: 81,
        getX: function() { return this.x; }
    };

    module.getX(); // 81

    var retrieveX = module.getX;
    retrieveX();   
    // returns 9 - The function gets invoked at the global scope

    // Create a new function with 'this' bound to module
    // New programmers might confuse the
    // global var x with module's property x
    var boundGetX = retrieveX.bind(module);
    boundGetX(); // 81    
*/

console.log("\n[ .reduce() ]-----------------------------------------------------------------------\n");
    // The reduce() method applies a function against an accumulator and each element in the array (from left to right) to reduce it to a single value.
    // arr.reduce(callback[, initialValue])


    // ex1 -----------------------------------------------------------------------------
    var array1 = [1, 2, 3, 4];
    var reducer = (accumulator, currentValue) => accumulator + currentValue;

    // 1 + 2 + 3 + 4
    console.log(array1.reduce(reducer));
    // expected output: 10

    // 5 + 1 + 2 + 3 + 4
    console.log(array1.reduce(reducer, 5)); // initial value 5
    // expected output: 15



    // ex2 : Flatten an array of arrays -----------------------------------------------------------------------------
    var flattened = [[0, 1], [2, 3], [4, 5]].reduce(
        function(accumulator, currentValue) {
            return accumulator.concat(currentValue);
        },[]
    );
    // flattened is [0, 1, 2, 3, 4, 5]

    // Alternatively, written with an arrow function:
    var flattened = [[0, 1], [2, 3], [4, 5]].reduce(
        ( accumulator, currentValue ) => accumulator.concat(currentValue),[] 
    );


    // ex2 : Grouping objects by a property -----------------------------------------------------------------------------
    var people = [
        { name: 'Alice', age: 21 },
        { name: 'Max', age: 20 },
        { name: 'Jane', age: 20 }
    ];

    function groupBy(objectArray, property) {
        return objectArray.reduce(function (acc, obj) {
            var key = obj[property];
            if (!acc[key]) {
                acc[key] = [];
            }
            acc[key].push(obj);
            return acc;
        }, {});
    }

    var groupedPeople = groupBy(people, 'age');
    // groupedPeople is:
    // { 
    //   20: [
    //     { name: 'Max', age: 20 }, 
    //     { name: 'Jane', age: 20 }
    //   ], 
    //   21: [{ name: 'Alice', age: 21 }] 
    // }


console.log("\n[ Compare Arrays ]-----------------------------------------------------------------------\n");
    var A = [0,1,2]; 
    var B = [2,1,0];
    var C = [3,1,0];

    console.log(A.every( e => B.includes(e) )); // true
    console.log(A.every( e => C.includes(e) )); // false

    console.log(A.every( e => B.indexOf(e) > -1  )); // true
    console.log(A.every( e => C.indexOf(e) > -1  )); // false

    // check at least one element present in the second array.....
    console.log(A.some( e => B.includes(e) )); // true
    console.log(A.some( e => C.includes(e) )); // false



console.log("\n[ 'for in' vs 'for of' ]-----------------------------------------------------------------------\n");
    var a1 = [1,2,3,4,5];
    var o1 = [
        {id:1, item:'it1'},
        {id:2, item:'it2'},
        {id:3, item:'it3'},
        {id:4, item:'it4'},
        {id:5, item:'it5'},
    ];
    var o2 = {
        a: 'itm1',
        b: 'itm2',
        c: 'itm3',
        d: 'itm4',
        e: 'itm5',
    };
    var s1 = 'abcdefg';

    console.log("\n Regular For loop +++++++++++++++++++++++++++++++\n");
    for(var i = 0; i<5; i++){
        console.log(a1[i], typeof(a1[i])); // number
    }
    for(var i = 0; i<5; i++){
        console.log(o1[i].id, typeof(o1[i].id)); // number
    }
    for(var i = 0; i<s1.length; i++){
        // console.log(s1, s1.substr(i,1));
        // console.log(s1, s1.slice(i,i+1));
    }


    console.log("\n 'for in' +++++++++++++++++++++++++++++++\n");
    for(const itm in a1){
        console.log(itm, typeof(itm)); // string....
    }

    for(const key in o2){
        console.log(o2[key]); // string....
    }

    console.log("\n 'for of' +++++++++++++++++++++++++++++++\n");

    for(const itm of a1){
        console.log(itm, typeof(itm)); // number
    }

    for(const itm of o1){
        console.log(itm.id, typeof(itm.id)); // number
    }





console.log("\n[ .Set() ]-----------------------------------------------------------------------\n");

    // ex1 -----------------------------------------------------------------------------
    const set1 = new Set([1, 2, 3, 4, 5]);
    console.log(set1.has(1)); // expected output: true
    console.log(set1.has(5)); // expected output: true
    console.log(set1.has(6)); // expected output: false


    // ex2 : Using the Set object-----------------------------------------------------------------------------
    var mySet = new Set();

    mySet.add(1); // Set [ 1 ]
    mySet.add(5); // Set [ 1, 5 ]
    mySet.add(5); // Set [ 1, 5 ]
    mySet.add('some text'); // Set [ 1, 5, 'some text' ]
    var o = {a: 1, b: 2};
    mySet.add(o);
    mySet.add({a: 1, b: 2}); // o is referencing a different object so this is okay
    mySet.has(1); // true
    mySet.has(3); // false, 3 has not been added to the set
    mySet.has(5);              // true
    mySet.has(Math.sqrt(25));  // true
    mySet.has('Some Text'.toLowerCase()); // true
    mySet.has(o); // true
    mySet.size; // 5
    mySet.delete(5); // removes 5 from the set
    mySet.has(5);    // false, 5 has been removed
    mySet.size; // 4, we just removed one value
    console.log(mySet);// Set [ 1, "some text", Object {a: 1, b: 2}, Object {a: 1, b: 2} ]


    // ex3 : Iterating Sets-----------------------------------------------------------------------------
    // iterate over items in set
    // logs the items in the order: 1, "some text", {"a": 1, "b": 2}, {"a": 1, "b": 2} 
    for (let item of mySet) console.log(item);

    // logs the items in the order: 1, "some text", {"a": 1, "b": 2}, {"a": 1, "b": 2} 
    for (let item of mySet.keys()) console.log(item);
    
    // logs the items in the order: 1, "some text", {"a": 1, "b": 2}, {"a": 1, "b": 2} 
    for (let item of mySet.values()) console.log(item);

    // logs the items in the order: 1, "some text", {"a": 1, "b": 2}, {"a": 1, "b": 2} 
    //(key and value are the same here)
    for (let [key, value] of mySet.entries()) console.log(key);

    // convert Set object to an Array object, with Array.from
    var myArr = Array.from(mySet); // [1, "some text", {"a": 1, "b": 2}, {"a": 1, "b": 2}]

    // the following will also work if run in an HTML document
    mySet.add(document.body);
    mySet.has(document.querySelector('body')); // true

    // converting between Set and Array
    var mySet2 = new Set([1, 2, 3, 4]);
    console.log(mySet2.size); // 4
    console.log([...mySet2]); // [1, 2, 3, 4]

    // intersect can be simulated via 
    var intersection = new Set([...mySet].filter(x => mySet2.has(x)));

    // difference can be simulated via
    var difference = new Set([...mySet].filter(x => !mySet2.has(x)));

    // Iterate set entries with forEach
    mySet.forEach(function(value) {
        console.log(value);
    });



    // ex3 : Implementing basic set operations-----------------------------------------------------------------------------
    function isSuperset1(set, subset) {
        for (var elem of subset) {
            if (!set.has(elem)) {
                return false;
            }
        }
        return true;
    }

    function union1(setA, setB) {
        var _union = new Set(setA);
        for (var elem of setB) {
            _union.add(elem);
        }
        return _union;
    }

    function intersection1(setA, setB) {
        var _intersection = new Set();
        for (var elem of setB) {
            if (setA.has(elem)) {
                _intersection.add(elem);
            }
        }
        return _intersection;
    }

    function difference1(setA, setB) {
        var _difference = new Set(setA);
        for (var elem of setB) {
            _difference.delete(elem);
        }
        return _difference;
    }

    //Examples
    var setA = new Set([1, 2, 3, 4]),
        setB = new Set([2, 3]),
        setC = new Set([3, 4, 5, 6]);

    isSuperset1(setA, setB); // => true
    union1(setA, setC); // => Set [1, 2, 3, 4, 5, 6]
    intersection1(setA, setC); // => Set [3, 4]
    difference1(setA, setC); // => Set [1, 2]




console.log("\n[ call()  ]-----------------------------------------------------------------------\n");
    // The call() method calls a function with a given this value and arguments provided individually.
    // function.call(thisArg, arg1, arg2, ...)

    // ex1 -----------------------------------------------------------------------------
    function Product(name, price) {
        this.name = name;
        this.price = price;
    }

    function Food(name, price) {
        Product.call(this, name, price);
        this.category = 'food';
    }

    function Toy(name, price) {
        Product.call(this, name, price);
        this.category = 'toy';
    }

    var cheese = new Food('feta', 5);
    var fun = new Toy('robot', 40);

    // ex2 -----------------------------------------------------------------------------
    var animals = [
        { species: 'Lion', name: 'King' },
        { species: 'Whale', name: 'Fail' }
    ];

    for (var i = 0; i < animals.length; i++) {
        (function(i) {
            this.print = function() {
            console.log('#' + i + ' ' + this.species
                        + ': ' + this.name);
            }
            this.print();
        }).call(animals[i], i);
    }
































	</script>


</body>

</html>