<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
    <script>

        let log = console.log;

        add(1,2); // Works
        function add(a,b){
            log(a+b);
        }
        add(1,2); // Works

        // Anonimus Function.*************
        // add2(1,2); // Error
        var add2 = function(a,b){
            log(a+b);
        }
        add2(1,2); // Works



        // str.slice(beginIndex[, endIndex-1])
        let str1 = "123456";
        log("str1",str1);
        let str1Sliced = str1.slice(0,3);
        log("str1Sliced",str1Sliced);


        let a = [1,2,3,4,5];
        let sliced = a.slice(0,3); // start index, endIndex-1
        log("sliced",sliced);

        log("a",a);
        a.pop() // take out last one
        log("a after pop: ",a);
        a.push("five","Six") // add to last
        log("a after push",a);

        a.shift();
        log("a after shift:",a);
        a.unshift("One", "Two");
        log("a after unshift: ",a);




        // copy array
        let copiedByConcat = a.concat();
        let copiedBySlice  = a.slice(0,a.length); // start and end index
        log("a",a);
        log("copiedByConcat",copiedByConcat);
        log("copiedBySlice",copiedBySlice);


        let sortedA = a.concat().sort();
        log("sortedA: ", sortedA);

        let sortedAReversed = a.concat().sort().reverse();
        log("sortedAReversed: ", sortedAReversed);


        //********************************************************************************
        // slice() 메서드는 어떤 배열의 begin부터 end까지(end 미포함)에 
        // 대한 얕은 복사본을 새로운 배열 객체로 반환합니다. 원본 배열은 바뀌지 않습니다.
        // arr.slice([begin index[, end index -1]])
        const animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];

        console.log(animals.slice(2));
        // expected output: Array ["camel", "duck", "elephant"]

        console.log(animals.slice(2, 4));
        // expected output: Array ["camel", "duck"]

        console.log(animals.slice(1, 5));
        // expected output: Array ["bison", "camel", "duck", "elephant"]
        
        log("\n\n");

        function argTest(){
            log(typeof(arguments), arguments);
            // return [].slice.call(arguments);
            return Array.prototype.slice.call(arguments);
        }

        let argTestResult = argTest(1,2,3);
        log("argTestResult",argTestResult);

        


        // ************************************************************
        // Call, Apply, Bind
        // sharing method between objects...
        // functionName.call(object, arguments)
        // functionName.apply(object, ArrayList)
        // variable = functionName.bind(object)
        //      variable(arguments)

        var obj1 = { num: 10 };
        var obj2 = { num: 20 };
        var obj3 = { num: 30 };

        var sharedFunction = function(a,b,c){
            return this.num + (a+b+c); // so 'this.num' is undefind here.... define upon call, apply, bind..
        }

        console.log("obj1 call:", sharedFunction.call(obj1, 1,2,3));
        console.log("obj2 apply:", sharedFunction.apply(obj2, [1,2,3]));

        var binded = sharedFunction.bind(obj3);
        console.log("obj3 binded", binded(1,2,3));
        










        // Prototype Call 
        // call() 메소드는 주어진 this 값 및 각각 전달된 인수와 함께 함수를 호출합니다.
        // 주의: 이 함수 구문은 apply()와 거의 동일하지만, call()은 인수 목록을, 
        // 반면에 apply()는 인수 배열 하나를 받는다는 점이 중요한 차이점입니다.
        // func.call(thisArg[, arg1[, arg2[, ...]]])
        function Product(name, price) {
            this.name = name;
            this.price = price;
        }

        function Food(name, price) {
            Product.call(this, name, price);
            this.category = 'food';
        }

        console.log(new Food('cheese', 5).name);
        // expected output: "cheese"
        console.log(new Food('KimChi', 5).category);
        // expected output: "food"



        // Prototype Apply
        // apply() 메서드는 주어진 this 값과 배열 (또는 유사 배열 객체) 로 제공되는 arguments 로 함수를 호출합니다.
        // The apply() method calls a function with a given this value and arguments provided as an array (or an array-like object).
        // 참고: 이 함수의 구문은 거의 call() 구문과 유사합니다. 근본적인 차이점은  call() 은 함수에 전달될 인수 리스트를 받는데 비해, 
        // apply() 는 인수들의 단일 배열을 받는다는 점입니다.
        // Note: While the syntax of this function is almost identical to that of call(), 
        // the fundamental difference is that call() accepts an argument list, 
        // while apply() accepts a single array of arguments.
        // func.apply(thisArg, [argsArray])
        const numbers = [5, 6, 2, 3, 7];

        const max = Math.max.apply(null, numbers);

        console.log(max);
        // expected output: 7

        const min = Math.min.apply(null, numbers);

        console.log(min);
        // expected output: 2









        
        //********************************************************************************
        // splice() 메서드는 배열의 기존 요소를 삭제 또는 교체하거나 새 요소를 추가하여 배열의 내용을 변경합니다.
        // array.splice(start[, deleteCount[, item1[, item2[, ...]]]])

        const months = ['Jan', 'March', 'April', 'June'];
        months.splice(1, 0, 'Feb');
        // inserts at index 1
        console.log(months);
        // expected output: Array ["Jan", "Feb", "March", "April", "June"]

        months.splice(4, 1, 'May');
        // replaces 1 element at index 4
        console.log(months);
        // expected output: Array ["Jan", "Feb", "March", "April", "May"]

        months.splice(months.length-1, 0, 'Jun', 'July', 'August');
        // replaces 1 element at index 4
        console.log(months);
        // expected output: Array ["Jan", "Feb", "March", "April", "Jun", "July", "August", "May"]


        log("\n\n");



</script>

</body>
</html>